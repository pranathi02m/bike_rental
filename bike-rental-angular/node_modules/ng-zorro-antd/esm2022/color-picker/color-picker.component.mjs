import { __decorate } from "tslib";
/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { NgTemplateOutlet } from '@angular/common';
import { ChangeDetectionStrategy, Component, EventEmitter, forwardRef, Input, Output } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { defaultColor, generateColor, NgAntdColorPickerModule } from 'ng-antd-color-picker';
import { InputBoolean, isNonEmptyString, isTemplateRef } from 'ng-zorro-antd/core/util';
import { NzPopoverDirective } from 'ng-zorro-antd/popover';
import { NzColorBlockComponent } from './color-block.component';
import { NzColorFormatComponent } from './color-format.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "ng-antd-color-picker";
export class NzColorPickerComponent {
    constructor(formBuilder, cdr) {
        this.formBuilder = formBuilder;
        this.cdr = cdr;
        this.nzFormat = null;
        this.nzValue = '';
        this.nzSize = 'default';
        this.nzDefaultValue = '';
        this.nzTrigger = 'click';
        this.nzTitle = '';
        this.nzFlipFlop = null;
        this.nzShowText = false;
        this.nzOpen = false;
        this.nzAllowClear = false;
        this.nzDisabled = false;
        this.nzDisabledAlpha = false;
        this.nzOnChange = new EventEmitter();
        this.nzOnFormatChange = new EventEmitter();
        this.nzOnClear = new EventEmitter();
        this.nzOnOpenChange = new EventEmitter();
        this.isTemplateRef = isTemplateRef;
        this.isNonEmptyString = isNonEmptyString;
        this.destroy$ = new Subject();
        this.isNzDisableFirstChange = true;
        this.blockColor = '';
        this.clearColor = false;
        this.showText = defaultColor.toHexString();
        this.formControl = this.formBuilder.control('');
        this.onChange = () => { };
    }
    writeValue(value) {
        this.nzValue = value;
        this.getBlockColor();
        this.formControl.patchValue(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched() { }
    setDisabledState(isDisabled) {
        this.nzDisabled = (this.isNzDisableFirstChange && this.nzDisabled) || isDisabled;
        this.isNzDisableFirstChange = false;
        this.cdr.markForCheck();
    }
    ngOnInit() {
        this.getBlockColor();
        this.formControl.valueChanges.pipe(takeUntil(this.destroy$)).subscribe(value => {
            if (!!value) {
                let color = value;
                if (this.nzFormat === 'hex') {
                    color =
                        generateColor(value).getAlpha() < 1
                            ? generateColor(value).toHex8String()
                            : generateColor(value).toHexString();
                }
                else if (this.nzFormat === 'hsb') {
                    color = generateColor(value).toHsbString();
                }
                else if (this.nzFormat === 'rgb') {
                    color = generateColor(value).toRgbString();
                }
                this.showText = color;
                this.onChange(color);
                this.cdr.markForCheck();
            }
        });
    }
    ngOnChanges(changes) {
        const { nzValue, nzDefaultValue } = changes;
        if (nzValue || nzDefaultValue) {
            this.getBlockColor();
        }
    }
    clearColorHandle() {
        this.clearColor = true;
        this.nzOnClear.emit(true);
        this.cdr.markForCheck();
    }
    getBlockColor() {
        if (!!this.nzValue) {
            this.blockColor = generateColor(this.nzValue).toRgbString();
        }
        else if (!!this.nzDefaultValue) {
            this.blockColor = generateColor(this.nzDefaultValue).toRgbString();
        }
        else {
            this.blockColor = defaultColor.toHexString();
        }
    }
    colorChange(value) {
        this.blockColor = value.color.getAlpha() < 1 ? value.color.toHex8String() : value.color.toHexString();
        this.clearColor = false;
        this.cdr.markForCheck();
    }
    formatChange(value) {
        this.nzValue = value.color;
        this.clearColor = false;
        this.getBlockColor();
        this.nzOnChange.emit({ color: generateColor(value.color), format: value.format });
        this.formControl.patchValue(value.color);
        this.cdr.markForCheck();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    get isNzTitleNonEmptyString() {
        return isNonEmptyString(this.nzTitle);
    }
    get isNzTitleTemplateRef() {
        return isTemplateRef(this.nzTitle);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.9", ngImport: i0, type: NzColorPickerComponent, deps: [{ token: i1.FormBuilder }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.0.9", type: NzColorPickerComponent, isStandalone: true, selector: "nz-color-picker", inputs: { nzFormat: "nzFormat", nzValue: "nzValue", nzSize: "nzSize", nzDefaultValue: "nzDefaultValue", nzTrigger: "nzTrigger", nzTitle: "nzTitle", nzFlipFlop: "nzFlipFlop", nzShowText: "nzShowText", nzOpen: "nzOpen", nzAllowClear: "nzAllowClear", nzDisabled: "nzDisabled", nzDisabledAlpha: "nzDisabledAlpha" }, outputs: { nzOnChange: "nzOnChange", nzOnFormatChange: "nzOnFormatChange", nzOnClear: "nzOnClear", nzOnOpenChange: "nzOnOpenChange" }, host: { properties: { "class.ant-color-picker-disabled": "nzDisabled" }, classAttribute: "ant-color-picker-inline" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NzColorPickerComponent),
                multi: true
            }
        ], exportAs: ["NzColorPicker"], usesOnChanges: true, ngImport: i0, template: `
    <div
      [class.ant-color-picker-trigger]="!nzFlipFlop"
      [class.ant-color-picker-sm]="nzSize === 'small'"
      [class.ant-color-picker-lg]="nzSize === 'large'"
      nz-popover
      [nzPopoverContent]="colorPicker"
      [nzPopoverTrigger]="!nzDisabled ? nzTrigger : null"
      [nzPopoverVisible]="nzOpen"
      (nzPopoverVisibleChange)="nzOnOpenChange.emit($event)"
    >
      @if (!nzFlipFlop) {
        <nz-color-block [nzColor]="blockColor" [nzSize]="nzSize" />
      } @else {
        <ng-template [ngTemplateOutlet]="nzFlipFlop" />
      }
      @if (nzShowText && !!showText && !nzFlipFlop) {
        <div class="ant-color-picker-trigger-text">
          {{ showText }}
        </div>
      }
    </div>
    <ng-template #colorPicker>
      <ng-antd-color-picker
        [value]="nzValue"
        [defaultValue]="nzDefaultValue"
        [disabled]="nzDisabled"
        [panelRenderHeader]="nzPanelRenderHeader"
        [panelRenderFooter]="nzPanelRenderFooter"
        [disabledAlpha]="nzDisabledAlpha"
        (nzOnChange)="colorChange($event)"
      />
    </ng-template>
    <ng-template #nzPanelRenderHeader>
      @if (nzTitle || nzAllowClear) {
        <div class="ant-color-picker-title">
          <div class="ant-color-picker-title-content">
            @if (isNzTitleTemplateRef) {
              <ng-container *ngTemplateOutlet="$any(nzTitle)" />
            }
            @if (isNzTitleNonEmptyString) {
              <span [innerHTML]="nzTitle"></span>
            }
          </div>
          @if (nzAllowClear) {
            <div class="ant-color-picker-clear" (click)="clearColorHandle()"></div>
          }
        </div>
      }
    </ng-template>
    <ng-template #nzPanelRenderFooter>
      <nz-color-format
        [colorValue]="blockColor"
        [clearColor]="clearColor"
        [format]="nzFormat"
        [nzDisabledAlpha]="nzDisabledAlpha"
        (formatChange)="formatChange($event)"
        (nzOnFormatChange)="nzOnFormatChange.emit($event)"
      />
    </ng-template>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: NgAntdColorPickerModule }, { kind: "component", type: i2.NgAntdColorPickerComponent, selector: "ng-antd-color-picker", inputs: ["value", "defaultValue", "panelRenderHeader", "panelRenderFooter", "disabledAlpha", "disabled"], outputs: ["nzOnChange", "nzOnChangeComplete"] }, { kind: "directive", type: NzPopoverDirective, selector: "[nz-popover]", inputs: ["nzPopoverArrowPointAtCenter", "nzPopoverTitle", "nzPopoverContent", "nz-popover", "nzPopoverTrigger", "nzPopoverPlacement", "nzPopoverOrigin", "nzPopoverVisible", "nzPopoverMouseEnterDelay", "nzPopoverMouseLeaveDelay", "nzPopoverOverlayClassName", "nzPopoverOverlayStyle", "nzPopoverBackdrop"], outputs: ["nzPopoverVisibleChange"], exportAs: ["nzPopover"] }, { kind: "component", type: NzColorBlockComponent, selector: "nz-color-block", inputs: ["nzColor", "nzSize"], outputs: ["nzOnClick"], exportAs: ["NzColorBlock"] }, { kind: "component", type: NzColorFormatComponent, selector: "nz-color-format", inputs: ["format", "colorValue", "clearColor", "nzDisabledAlpha"], outputs: ["formatChange", "nzOnFormatChange"], exportAs: ["NzColorFormat"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
__decorate([
    InputBoolean()
], NzColorPickerComponent.prototype, "nzShowText", void 0);
__decorate([
    InputBoolean()
], NzColorPickerComponent.prototype, "nzOpen", void 0);
__decorate([
    InputBoolean()
], NzColorPickerComponent.prototype, "nzAllowClear", void 0);
__decorate([
    InputBoolean()
], NzColorPickerComponent.prototype, "nzDisabled", void 0);
__decorate([
    InputBoolean()
], NzColorPickerComponent.prototype, "nzDisabledAlpha", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.9", ngImport: i0, type: NzColorPickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-color-picker',
                    exportAs: 'NzColorPicker',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    standalone: true,
                    imports: [
                        NgAntdColorPickerModule,
                        NzPopoverDirective,
                        NzColorBlockComponent,
                        NzColorFormatComponent,
                        NgTemplateOutlet
                    ],
                    template: `
    <div
      [class.ant-color-picker-trigger]="!nzFlipFlop"
      [class.ant-color-picker-sm]="nzSize === 'small'"
      [class.ant-color-picker-lg]="nzSize === 'large'"
      nz-popover
      [nzPopoverContent]="colorPicker"
      [nzPopoverTrigger]="!nzDisabled ? nzTrigger : null"
      [nzPopoverVisible]="nzOpen"
      (nzPopoverVisibleChange)="nzOnOpenChange.emit($event)"
    >
      @if (!nzFlipFlop) {
        <nz-color-block [nzColor]="blockColor" [nzSize]="nzSize" />
      } @else {
        <ng-template [ngTemplateOutlet]="nzFlipFlop" />
      }
      @if (nzShowText && !!showText && !nzFlipFlop) {
        <div class="ant-color-picker-trigger-text">
          {{ showText }}
        </div>
      }
    </div>
    <ng-template #colorPicker>
      <ng-antd-color-picker
        [value]="nzValue"
        [defaultValue]="nzDefaultValue"
        [disabled]="nzDisabled"
        [panelRenderHeader]="nzPanelRenderHeader"
        [panelRenderFooter]="nzPanelRenderFooter"
        [disabledAlpha]="nzDisabledAlpha"
        (nzOnChange)="colorChange($event)"
      />
    </ng-template>
    <ng-template #nzPanelRenderHeader>
      @if (nzTitle || nzAllowClear) {
        <div class="ant-color-picker-title">
          <div class="ant-color-picker-title-content">
            @if (isNzTitleTemplateRef) {
              <ng-container *ngTemplateOutlet="$any(nzTitle)" />
            }
            @if (isNzTitleNonEmptyString) {
              <span [innerHTML]="nzTitle"></span>
            }
          </div>
          @if (nzAllowClear) {
            <div class="ant-color-picker-clear" (click)="clearColorHandle()"></div>
          }
        </div>
      }
    </ng-template>
    <ng-template #nzPanelRenderFooter>
      <nz-color-format
        [colorValue]="blockColor"
        [clearColor]="clearColor"
        [format]="nzFormat"
        [nzDisabledAlpha]="nzDisabledAlpha"
        (formatChange)="formatChange($event)"
        (nzOnFormatChange)="nzOnFormatChange.emit($event)"
      />
    </ng-template>
  `,
                    host: {
                        class: 'ant-color-picker-inline',
                        '[class.ant-color-picker-disabled]': `nzDisabled`
                    },
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => NzColorPickerComponent),
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: () => [{ type: i1.FormBuilder }, { type: i0.ChangeDetectorRef }], propDecorators: { nzFormat: [{
                type: Input
            }], nzValue: [{
                type: Input
            }], nzSize: [{
                type: Input
            }], nzDefaultValue: [{
                type: Input
            }], nzTrigger: [{
                type: Input
            }], nzTitle: [{
                type: Input
            }], nzFlipFlop: [{
                type: Input
            }], nzShowText: [{
                type: Input
            }], nzOpen: [{
                type: Input
            }], nzAllowClear: [{
                type: Input
            }], nzDisabled: [{
                type: Input
            }], nzDisabledAlpha: [{
                type: Input
            }], nzOnChange: [{
                type: Output
            }], nzOnFormatChange: [{
                type: Output
            }], nzOnClear: [{
                type: Output
            }], nzOnOpenChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3ItcGlja2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL2NvbG9yLXBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFDTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULFlBQVksRUFDWixVQUFVLEVBQ1YsS0FBSyxFQUlMLE1BQU0sRUFHUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXFDLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUc1RixPQUFPLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3hGLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRTNELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDOzs7O0FBd0ZsRSxNQUFNLE9BQU8sc0JBQXNCO0lBZ0NqQyxZQUNVLFdBQXdCLEVBQ3hCLEdBQXNCO1FBRHRCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLFFBQUcsR0FBSCxHQUFHLENBQW1CO1FBM0J2QixhQUFRLEdBQW1DLElBQUksQ0FBQztRQUNoRCxZQUFPLEdBQXFCLEVBQUUsQ0FBQztRQUMvQixXQUFNLEdBQWtCLFNBQVMsQ0FBQztR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QUFjO3NCQUF0QixLQUFLO2dCQUNHLFNBQVM7c0JBQWpCLEtBQUs7Z0JBQ0csT0FBTztzQkFBZixLQUFLO2dCQUNHLFVBQVU7c0JBQWxCLEtBQUs7Z0JBQ21CLFVBQVU7c0JBQWxDLEtBQUs7Z0JBQ21CLE1BQU07c0JBQTlCLEtBQUs7Z0JBQ21CLFlBQVk7c0JBQXBDLEtBQUs7Z0JBQ21CLFVBQVU7c0JBQWxDLEtBQUs7Z0JBQ21CLGVBQWU7c0JBQXZDLEtBQUs7Z0JBQ2EsVUFBVTtzQkFBNUIsTUFBTTtnQkFDWSxnQkFBZ0I7c0JBQWxDLE1BQU07Z0JBQ1ksU0FBUztzQkFBM0IsTUFBTTtnQkFDWSxjQUFjO3NCQUFoQyxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHsgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBmb3J3YXJkUmVmLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBGb3JtQnVpbGRlciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IGRlZmF1bHRDb2xvciwgZ2VuZXJhdGVDb2xvciwgTmdBbnRkQ29sb3JQaWNrZXJNb2R1bGUgfSBmcm9tICduZy1hbnRkLWNvbG9yLXBpY2tlcic7XG5cbmltcG9ydCB7IEJvb2xlYW5JbnB1dCwgTnpTYWZlQW55LCBOelNpemVMRFNUeXBlIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL3R5cGVzJztcbmltcG9ydCB7IElucHV0Qm9vbGVhbiwgaXNOb25FbXB0eVN0cmluZywgaXNUZW1wbGF0ZVJlZiB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS91dGlsJztcbmltcG9ydCB7IE56UG9wb3ZlckRpcmVjdGl2ZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvcG9wb3Zlcic7XG5cbmltcG9ydCB7IE56Q29sb3JCbG9ja0NvbXBvbmVudCB9IGZyb20gJy4vY29sb3ItYmxvY2suY29tcG9uZW50JztcbmltcG9ydCB7IE56Q29sb3JGb3JtYXRDb21wb25lbnQgfSBmcm9tICcuL2NvbG9yLWZvcm1hdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgTnpDb2xvciwgTnpDb2xvclBpY2tlckZvcm1hdFR5cGUsIE56Q29sb3JQaWNrZXJUcmlnZ2VyVHlwZSB9IGZyb20gJy4vdHlwaW5ncyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ256LWNvbG9yLXBpY2tlcicsXG4gIGV4cG9ydEFzOiAnTnpDb2xvclBpY2tlcicsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICBpbXBvcnRzOiBbXG4gICAgTmdBbnRkQ29sb3JQaWNrZXJNb2R1bGUsXG4gICAgTnpQb3BvdmVyRGlyZWN0aXZlLFxuICAgIE56Q29sb3JCbG9ja0NvbXBvbmVudCxcbiAgICBOekNvbG9yRm9ybWF0Q29tcG9uZW50LFxuICAgIE5nVGVtcGxhdGVPdXRsZXRcbiAgXSxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2XG4gICAgICBbY2xhc3MuYW50LWNvbG9yLXBpY2tlci10cmlnZ2VyXT1cIiFuekZsaXBGbG9wXCJcbiAgICAgIFtjbGFzcy5hbnQtY29sb3ItcGlja2VyLXNtXT1cIm56U2l6ZSA9PT0gJ3NtYWxsJ1wiXG4gICAgICBbY2xhc3MuYW50LWNvbG9yLXBpY2tlci1sZ109XCJuelNpemUgPT09ICdsYXJnZSdcIlxuICAgICAgbnotcG9wb3ZlclxuICAgICAgW256UG9wb3ZlckNvbnRlbnRdPVwiY29sb3JQaWNrZXJcIlxuICAgICAgW256UG9wb3ZlclRyaWdnZXJdPVwiIW56RGlzYWJsZWQgPyBuelRyaWdnZXIgOiBudWxsXCJcbiAgICAgIFtuelBvcG92ZXJWaXNpYmxlXT1cIm56T3BlblwiXG4gICAgICAobnpQb3BvdmVyVmlzaWJsZUNoYW5nZSk9XCJuek9uT3BlbkNoYW5nZS5lbWl0KCRldmVudClcIlxuICAgID5cbiAgICAgIEBpZiAoIW56RmxpcEZsb3ApIHtcbiAgICAgICAgPG56LWNvbG9yLWJsb2NrIFtuekNvbG9yXT1cImJsb2NrQ29sb3JcIiBbbnpTaXplXT1cIm56U2l6ZVwiIC8+XG4gICAgICB9IEBlbHNlIHtcbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm56RmxpcEZsb3BcIiAvPlxuICAgICAgfVxuICAgICAgQGlmIChuelNob3dUZXh0ICYmICEhc2hvd1RleHQgJiYgIW56RmxpcEZsb3ApIHtcbiAgICAgICAgPGRpdiBjbGFzcz1cImFudC1jb2xvci1waWNrZXItdHJpZ2dlci10ZXh0XCI+XG4gICAgICAgICAge3sgc2hvd1RleHQgfX1cbiAgICAgICAgPC9kaXY+XG4gICAgICB9XG4gICAgPC9kaXY+XG4gICAgPG5nLXRlbXBsYXRlICNjb2xvclBpY2tlcj5cbiAgICAgIDxuZy1hbnRkLWNvbG9yLXBpY2tlclxuICAgICAgICBbdmFsdWVdPVwibnpWYWx1ZVwiXG4gICAgICAgIFtkZWZhdWx0VmFsdWVdPVwibnpEZWZhdWx0VmFsdWVcIlxuICAgICAgICBbZGlzYWJsZWRdPVwibnpEaXNhYmxlZFwiXG4gICAgICAgIFtwYW5lbFJlbmRlckhlYWRlcl09XCJuelBhbmVsUmVuZGVySGVhZGVyXCJcbiAgICAgICAgW3BhbmVsUmVuZGVyRm9vdGVyXT1cIm56UGFuZWxSZW5kZXJGb290ZXJcIlxuICAgICAgICBbZGlzYWJsZWRBbHBoYV09XCJuekRpc2FibGVkQWxwaGFcIlxuICAgICAgICAobnpPbkNoYW5nZSk9XCJjb2xvckNoYW5nZSgkZXZlbnQpXCJcbiAgICAgIC8+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8bmctdGVtcGxhdGUgI256UGFuZWxSZW5kZXJIZWFkZXI+XG4gICAgICBAaWYgKG56VGl0bGUgfHwgbnpBbGxvd0NsZWFyKSB7XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbnQtY29sb3ItcGlja2VyLXRpdGxlXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImFudC1jb2xvci1waWNrZXItdGl0bGUtY29udGVudFwiPlxuICAgICAgICAgICAgQGlmIChpc056VGl0bGVUZW1wbGF0ZVJlZikge1xuICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiJGFueShuelRpdGxlKVwiIC8+XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAaWYgKGlzTnpUaXRsZU5vbkVtcHR5U3RyaW5nKSB7XG4gICAgICAgICAgICAgIDxzcGFuIFtpbm5lckhUTUxdPVwibnpUaXRsZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICBAaWYgKG56QWxsb3dDbGVhcikge1xuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFudC1jb2xvci1waWNrZXItY2xlYXJcIiAoY2xpY2spPVwiY2xlYXJDb2xvckhhbmRsZSgpXCI+PC9kaXY+XG4gICAgICAgICAgfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIH1cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIDxuZy10ZW1wbGF0ZSAjbnpQYW5lbFJlbmRlckZvb3Rlcj5cbiAgICAgIDxuei1jb2xvci1mb3JtYXRcbiAgICAgICAgW2NvbG9yVmFsdWVdPVwiYmxvY2tDb2xvclwiXG4gICAgICAgIFtjbGVhckNvbG9yXT1cImNsZWFyQ29sb3JcIlxuICAgICAgICBbZm9ybWF0XT1cIm56Rm9ybWF0XCJcbiAgICAgICAgW256RGlzYWJsZWRBbHBoYV09XCJuekRpc2FibGVkQWxwaGFcIlxuICAgICAgICAoZm9ybWF0Q2hhbmdlKT1cImZvcm1hdENoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgKG56T25Gb3JtYXRDaGFuZ2UpPVwibnpPbkZvcm1hdENoYW5nZS5lbWl0KCRldmVudClcIlxuICAgICAgLz5cbiAgICA8L25nLXRlbXBsYXRlPlxuICBgLFxuICBob3N0OiB7XG4gICAgY2xhc3M6ICdhbnQtY29sb3ItcGlja2VyLWlubGluZScsXG4gICAgJ1tjbGFzcy5hbnQtY29sb3ItcGlja2VyLWRpc2FibGVkXSc6IGBuekRpc2FibGVkYFxuICB9LFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE56Q29sb3JQaWNrZXJDb21wb25lbnQpLFxuICAgICAgbXVsdGk6IHRydWVcbiAgICB9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgTnpDb2xvclBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25EZXN0cm95IHtcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX256U2hvd1RleHQ6IEJvb2xlYW5JbnB1dDtcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX256T3BlbjogQm9vbGVhbklucHV0O1xuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbnpBbGxvd0NsZWFyOiBCb29sZWFuSW5wdXQ7XG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9uekRpc2FibGVkOiBCb29sZWFuSW5wdXQ7XG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9uekRpc2FibGVkQWxwaGE6IEJvb2xlYW5JbnB1dDtcblxuICBASW5wdXQoKSBuekZvcm1hdDogTnpDb2xvclBpY2tlckZvcm1hdFR5cGUgfCBudWxsID0gbnVsbDtcbiAgQElucHV0KCkgbnpWYWx1ZTogc3RyaW5nIHwgTnpDb2xvciA9ICcnO1xuICBASW5wdXQoKSBuelNpemU6IE56U2l6ZUxEU1R5cGUgPSAnZGVmYXVsdCc7XG4gIEBJbnB1dCgpIG56RGVmYXVsdFZhbHVlOiBzdHJpbmcgfCBOekNvbG9yID0gJyc7XG4gIEBJbnB1dCgpIG56VHJpZ2dlcjogTnpDb2xvclBpY2tlclRyaWdnZXJUeXBlID0gJ2NsaWNrJztcbiAgQElucHV0KCkgbnpUaXRsZTogVGVtcGxhdGVSZWY8dm9pZD4gfCBzdHJpbmcgPSAnJztcbiAgQElucHV0KCkgbnpGbGlwRmxvcDogVGVtcGxhdGVSZWY8dm9pZD4gfCBudWxsID0gbnVsbDtcbiAgQElucHV0KCkgQElucHV0Qm9vbGVhbigpIG56U2hvd1RleHQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCkgQElucHV0Qm9vbGVhbigpIG56T3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoKSBASW5wdXRCb29sZWFuKCkgbnpBbGxvd0NsZWFyOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIEBJbnB1dEJvb2xlYW4oKSBuekRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIEBJbnB1dEJvb2xlYW4oKSBuekRpc2FibGVkQWxwaGE6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IG56T25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHsgY29sb3I6IE56Q29sb3I7IGZvcm1hdDogc3RyaW5nIH0+KCk7XG4gIEBPdXRwdXQoKSByZWFkb25seSBuek9uRm9ybWF0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxOekNvbG9yUGlja2VyRm9ybWF0VHlwZT4oKTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IG56T25DbGVhciA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IG56T25PcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIHByb3RlY3RlZCByZWFkb25seSBpc1RlbXBsYXRlUmVmID0gaXNUZW1wbGF0ZVJlZjtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGlzTm9uRW1wdHlTdHJpbmcgPSBpc05vbkVtcHR5U3RyaW5nO1xuICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgcHJpdmF0ZSBpc056RGlzYWJsZUZpcnN0Q2hhbmdlOiBib29sZWFuID0gdHJ1ZTtcbiAgYmxvY2tDb2xvcjogc3RyaW5nID0gJyc7XG4gIGNsZWFyQ29sb3I6IGJvb2xlYW4gPSBmYWxzZTtcbiAgc2hvd1RleHQ6IHN0cmluZyA9IGRlZmF1bHRDb2xvci50b0hleFN0cmluZygpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZm9ybUJ1aWxkZXI6IEZvcm1CdWlsZGVyLFxuICAgIHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHt9XG5cbiAgZm9ybUNvbnRyb2wgPSB0aGlzLmZvcm1CdWlsZGVyLmNvbnRyb2woJycpO1xuXG4gIG9uQ2hhbmdlOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4gIHdyaXRlVmFsdWUodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMubnpWYWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuZ2V0QmxvY2tDb2xvcigpO1xuICAgIHRoaXMuZm9ybUNvbnRyb2wucGF0Y2hWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBOelNhZmVBbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZCgpOiB2b2lkIHt9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5uekRpc2FibGVkID0gKHRoaXMuaXNOekRpc2FibGVGaXJzdENoYW5nZSAmJiB0aGlzLm56RGlzYWJsZWQpIHx8IGlzRGlzYWJsZWQ7XG4gICAgdGhpcy5pc056RGlzYWJsZUZpcnN0Q2hhbmdlID0gZmFsc2U7XG4gICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmdldEJsb2NrQ29sb3IoKTtcbiAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgIGlmICghIXZhbHVlKSB7XG4gICAgICAgIGxldCBjb2xvciA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5uekZvcm1hdCA9PT0gJ2hleCcpIHtcbiAgICAgICAgICBjb2xvciA9XG4gICAgICAgICAgICBnZW5lcmF0ZUNvbG9yKHZhbHVlKS5nZXRBbHBoYSgpIDwgMVxuICAgICAgICAgICAgICA/IGdlbmVyYXRlQ29sb3IodmFsdWUpLnRvSGV4OFN0cmluZygpXG4gICAgICAgICAgICAgIDogZ2VuZXJhdGVDb2xvcih2YWx1ZSkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm56Rm9ybWF0ID09PSAnaHNiJykge1xuICAgICAgICAgIGNvbG9yID0gZ2VuZXJhdGVDb2xvcih2YWx1ZSkudG9Ic2JTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm56Rm9ybWF0ID09PSAncmdiJykge1xuICAgICAgICAgIGNvbG9yID0gZ2VuZXJhdGVDb2xvcih2YWx1ZSkudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3dUZXh0ID0gY29sb3I7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoY29sb3IpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBjb25zdCB7IG56VmFsdWUsIG56RGVmYXVsdFZhbHVlIH0gPSBjaGFuZ2VzO1xuICAgIGlmIChuelZhbHVlIHx8IG56RGVmYXVsdFZhbHVlKSB7XG4gICAgICB0aGlzLmdldEJsb2NrQ29sb3IoKTtcbiAgICB9XG4gIH1cblxuICBjbGVhckNvbG9ySGFuZGxlKCk6IHZvaWQge1xuICAgIHRoaXMuY2xlYXJDb2xvciA9IHRydWU7XG4gICAgdGhpcy5uek9uQ2xlYXIuZW1pdCh0cnVlKTtcbiAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIGdldEJsb2NrQ29sb3IoKTogdm9pZCB7XG4gICAgaWYgKCEhdGhpcy5uelZhbHVlKSB7XG4gICAgICB0aGlzLmJsb2NrQ29sb3IgPSBnZW5lcmF0ZUNvbG9yKHRoaXMubnpWYWx1ZSkudG9SZ2JTdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKCEhdGhpcy5uekRlZmF1bHRWYWx1ZSkge1xuICAgICAgdGhpcy5ibG9ja0NvbG9yID0gZ2VuZXJhdGVDb2xvcih0aGlzLm56RGVmYXVsdFZhbHVlKS50b1JnYlN0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJsb2NrQ29sb3IgPSBkZWZhdWx0Q29sb3IudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gIH1cblxuICBjb2xvckNoYW5nZSh2YWx1ZTogeyBjb2xvcjogTnpDb2xvciB9KTogdm9pZCB7XG4gICAgdGhpcy5ibG9ja0NvbG9yID0gdmFsdWUuY29sb3IuZ2V0QWxwaGEoKSA8IDEgPyB2YWx1ZS5jb2xvci50b0hleDhTdHJpbmcoKSA6IHZhbHVlLmNvbG9yLnRvSGV4U3RyaW5nKCk7XG4gICAgdGhpcy5jbGVhckNvbG9yID0gZmFsc2U7XG4gICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBmb3JtYXRDaGFuZ2UodmFsdWU6IHsgY29sb3I6IHN0cmluZzsgZm9ybWF0OiBOekNvbG9yUGlja2VyRm9ybWF0VHlwZSB9KTogdm9pZCB7XG4gICAgdGhpcy5uelZhbHVlID0gdmFsdWUuY29sb3I7XG4gICAgdGhpcy5jbGVhckNvbG9yID0gZmFsc2U7XG4gICAgdGhpcy5nZXRCbG9ja0NvbG9yKCk7XG4gICAgdGhpcy5uek9uQ2hhbmdlLmVtaXQoeyBjb2xvcjogZ2VuZXJhdGVDb2xvcih2YWx1ZS5jb2xvciksIGZvcm1hdDogdmFsdWUuZm9ybWF0IH0pO1xuICAgIHRoaXMuZm9ybUNvbnRyb2wucGF0Y2hWYWx1ZSh2YWx1ZS5jb2xvcik7XG4gICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gIH1cblxuICBnZXQgaXNOelRpdGxlTm9uRW1wdHlTdHJpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzTm9uRW1wdHlTdHJpbmcodGhpcy5uelRpdGxlKTtcbiAgfVxuXG4gIGdldCBpc056VGl0bGVUZW1wbGF0ZVJlZigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNUZW1wbGF0ZVJlZih0aGlzLm56VGl0bGUpO1xuICB9XG59XG4iXX0=