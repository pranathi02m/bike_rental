/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, Component, ViewEncapsulation } from '@angular/core';
import { valueFunctionProp } from 'ng-zorro-antd/core/util';
import { AbstractTable } from './abstract-table';
import { NgClass, NgForOf, NgIf, NgSwitch, NgSwitchCase, NgSwitchDefault, NgTemplateOutlet } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "ng-zorro-antd/i18n";
export class YearTableComponent extends AbstractTable {
    constructor(dateHelper) {
        super();
        this.dateHelper = dateHelper;
        this.MAX_ROW = 4;
        this.MAX_COL = 3;
    }
    makeHeadRow() {
        return [];
    }
    makeBodyRows() {
        const currentYear = this.activeDate && this.activeDate.getYear();
        const startYear = parseInt(`${currentYear / 10}`, 10) * 10;
        const endYear = startYear + 9;
        const previousYear = startYear - 1;
        const years = [];
        let yearValue = 0;
        for (let rowIndex = 0; rowIndex < this.MAX_ROW; rowIndex++) {
            const row = {
                dateCells: [],
                trackByIndex: rowIndex
            };
            for (let colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
                const yearNum = previousYear + yearValue;
                const year = this.activeDate.setYear(yearNum);
                const content = this.dateHelper.format(year.nativeDate, 'yyyy');
                const isDisabled = this.isDisabledYear(year);
                const cell = {
                    trackByIndex: colIndex,
                    value: year.nativeDate,
                    isDisabled,
                    isSameDecade: yearNum >= startYear && yearNum <= endYear,
                    isSelected: yearNum === (this.value && this.value.getYear()),
                    content,
                    title: content,
                    classMap: {},
                    isLastCellInPanel: year.getYear() === endYear,
                    isFirstCellInPanel: year.getYear() === startYear,
                    cellRender: valueFunctionProp(this.cellRender, year),
                    fullCellRender: valueFunctionProp(this.fullCellRender, year),
                    onClick: () => this.chooseYear(cell.value.getFullYear()),
                    onMouseEnter: () => this.cellHover.emit(year)
                };
                this.addCellProperty(cell, year);
                row.dateCells.push(cell);
                yearValue++;
            }
            years.push(row);
        }
        return years;
    }
    getClassMap(cell) {
        return {
            ...super.getClassMap(cell),
            [`ant-picker-cell-in-view`]: !!cell.isSameDecade
        };
    }
    isDisabledYear(year) {
        if (!this.disabledDate) {
            return false;
        }
        const firstOfMonth = year.setMonth(0).setDate(1);
        for (let date = firstOfMonth; date.getYear() === year.getYear(); date = date.addDays(1)) {
            if (!this.disabledDate(date.nativeDate)) {
                return false;
            }
        }
        return true;
    }
    addCellProperty(cell, year) {
        if (this.hasRangeValue()) {
            const [startHover, endHover] = this.hoverValue;
            const [startSelected, endSelected] = this.selectedValue;
            // Selected
            if (startSelected?.isSameYear(year)) {
                cell.isSelectedStart = true;
                cell.isSelected = true;
            }
            if (endSelected?.isSameYear(year)) {
                cell.isSelectedEnd = true;
                cell.isSelected = true;
            }
            if (startHover && endHover) {
                cell.isHoverStart = startHover.isSameYear(year);
                cell.isHoverEnd = endHover.isSameYear(year);
                cell.isInHoverRange = startHover.isBeforeYear(year) && year.isBeforeYear(endHover);
            }
            cell.isStartSingle = startSelected && !endSelected;
            cell.isEndSingle = !startSelected && endSelected;
            cell.isInSelectedRange = startSelected?.isBeforeYear(year) && year?.isBeforeYear(endSelected);
            cell.isRangeStartNearHover = startSelected && cell.isInHoverRange;
            cell.isRangeEndNearHover = endSelected && cell.isInHoverRange;
        }
        else if (year.isSameYear(this.value)) {
            cell.isSelected = true;
        }
        cell.classMap = this.getClassMap(cell);
    }
    chooseYear(year) {
        this.value = this.activeDate.setYear(year);
        this.valueChange.emit(this.value);
        this.render();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.9", ngImport: i0, type: YearTableComponent, deps: [{ token: i1.DateHelperService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.0.9", type: YearTableComponent, isStandalone: true, selector: "year-table", exportAs: ["yearTable"], usesInheritance: true, ngImport: i0, template: "<table class=\"ant-picker-content\" cellspacing=\"0\" role=\"grid\">\n  @if(headRow && headRow.length > 0) {\n    <thead>\n      <tr role=\"row\">\n        @if(showWeek) {\n          <th role=\"columnheader\"></th>\n        }\n        @for(cell of headRow; track cell) {\n          <th role=\"columnheader\" title=\"{{ cell.title }}\"> {{ cell.content }} </th>\n        }\n      </tr>\n    </thead>\n  }\n\n  <tbody>\n    @for(row of bodyRows; track row.trackByIndex) {\n      <tr [ngClass]=\"row.classMap!\" role=\"row\">\n        @if(row.weekNum) {\n          <td role=\"gridcell\" class=\"{{ prefixCls }}-cell-week\"> {{ row.weekNum }} </td>\n        }\n        @for(cell of row.dateCells; track cell.trackByIndex) {\n          <td\n            title=\"{{ cell.title }}\"\n            role=\"gridcell\"\n            [ngClass]=\"cell.classMap!\"\n            (click)=\"cell.isDisabled ? null : cell.onClick()\"\n            (mouseenter)=\"cell.onMouseEnter()\"\n          >\n            @switch (prefixCls) {\n              @case('ant-picker') {\n                @if(cell.isTemplateRef) {\n                  <ng-container *ngTemplateOutlet=\"$any(cell.cellRender); context: { $implicit: cell.value }\" />\n                }@else if(cell.isNonEmptyString) {\n                  <span [innerHTML]=\"cell.cellRender\"></span>\n                }@else {\n                  <div\n                    class=\"{{ prefixCls }}-cell-inner\"\n                    [attr.aria-selected]=\"cell.isSelected\"\n                    [attr.aria-disabled]=\"cell.isDisabled\"\n                  >\n                    {{ cell.content }}\n                  </div>\n                }\n              }\n              @case('ant-picker-calendar') {\n                <div\n                  class=\"{{ prefixCls }}-date ant-picker-cell-inner\"\n                  [class.ant-picker-calendar-date-today]=\"cell.isToday\"\n                >\n                  @if(cell.fullCellRender) {\n                    <ng-container *ngTemplateOutlet=\"$any(cell.fullCellRender); context: { $implicit: cell.value }\" />\n                  }@else() {\n                    <div class=\"{{ prefixCls }}-date-value\">{{ cell.content }}</div>\n                    <div class=\"{{ prefixCls }}-date-content\">\n                      <ng-container *ngTemplateOutlet=\"$any(cell.cellRender); context: { $implicit: cell.value }\">\n                      </ng-container>\n                    </div>\n                  }\n                </div>\n              }\n            }\n          </td>\n        }\n\n      </tr>\n    }\n  </tbody>\n</table>\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.9", ngImport: i0, type: YearTableComponent, decorators: [{
            type: Component,
            args: [{ encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, selector: 'year-table', exportAs: 'yearTable', imports: [NgIf, NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault], standalone: true, template: "<table class=\"ant-picker-content\" cellspacing=\"0\" role=\"grid\">\n  @if(headRow && headRow.length > 0) {\n    <thead>\n      <tr role=\"row\">\n        @if(showWeek) {\n          <th role=\"columnheader\"></th>\n        }\n        @for(cell of headRow; track cell) {\n          <th role=\"columnheader\" title=\"{{ cell.title }}\"> {{ cell.content }} </th>\n        }\n      </tr>\n    </thead>\n  }\n\n  <tbody>\n    @for(row of bodyRows; track row.trackByIndex) {\n      <tr [ngClass]=\"row.classMap!\" role=\"row\">\n        @if(row.weekNum) {\n          <td role=\"gridcell\" class=\"{{ prefixCls }}-cell-week\"> {{ row.weekNum }} </td>\n        }\n        @for(cell of row.dateCells; track cell.trackByIndex) {\n          <td\n            title=\"{{ cell.title }}\"\n            role=\"gridcell\"\n            [ngClass]=\"cell.classMap!\"\n            (click)=\"cell.isDisabled ? null : cell.onClick()\"\n            (mouseenter)=\"cell.onMouseEnter()\"\n          >\n            @switch (prefixCls) {\n              @case('ant-picker') {\n                @if(cell.isTemplateRef) {\n                  <ng-container *ngTemplateOutlet=\"$any(cell.cellRender); context: { $implicit: cell.value }\" />\n                }@else if(cell.isNonEmptyString) {\n                  <span [innerHTML]=\"cell.cellRender\"></span>\n                }@else {\n                  <div\n                    class=\"{{ prefixCls }}-cell-inner\"\n                    [attr.aria-selected]=\"cell.isSelected\"\n                    [attr.aria-disabled]=\"cell.isDisabled\"\n                  >\n                    {{ cell.content }}\n                  </div>\n                }\n              }\n              @case('ant-picker-calendar') {\n                <div\n                  class=\"{{ prefixCls }}-date ant-picker-cell-inner\"\n                  [class.ant-picker-calendar-date-today]=\"cell.isToday\"\n                >\n                  @if(cell.fullCellRender) {\n                    <ng-container *ngTemplateOutlet=\"$any(cell.fullCellRender); context: { $implicit: cell.value }\" />\n                  }@else() {\n                    <div class=\"{{ prefixCls }}-date-value\">{{ cell.content }}</div>\n                    <div class=\"{{ prefixCls }}-date-content\">\n                      <ng-container *ngTemplateOutlet=\"$any(cell.cellRender); context: { $implicit: cell.value }\">\n                      </ng-container>\n                    </div>\n                  }\n                </div>\n              }\n            }\n          </td>\n        }\n\n      </tr>\n    }\n  </tbody>\n</table>\n" }]
        }], ctorParameters: () => [{ type: i1.DateHelperService }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci10YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb21wb25lbnRzL2RhdGUtcGlja2VyL2xpYi95ZWFyLXRhYmxlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uL2NvbXBvbmVudHMvZGF0ZS1waWNrZXIvbGliL2Fic3RyYWN0LXRhYmxlLmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHO0FBRUgsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUd0RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUc1RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFakQsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7OztBQVlwSCxNQUFNLE9BQU8sa0JBQW1CLFNBQVEsYUFBYTtJQUluRCxZQUFvQixVQUE2QjtRQUMvQyxLQUFLLEVBQUUsQ0FBQztRQURVLGVBQVUsR0FBVixVQUFVLENBQW1CO1FBSHhDLFlBQU8sR0FBRyxDQUFDLENBQUM7UUFDWixZQUFPLEdBQUcsQ0FBQyxDQUFDO0lBSXJCLENBQUM7SUFFRCxXQUFXO1FBQ1QsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsWUFBWTtRQUNWLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqRSxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsR0FBRyxXQUFXLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzNELE1BQU0sT0FBTyxHQUFHLFNBQVMsR0FBRyxDQUFD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QUksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxDQUFDLGNBQ2hGLElBQUkiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ORy1aT1JSTy9uZy16b3Jyby1hbnRkL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDYW5keURhdGUgfSBmcm9tICduZy16b3Jyby1hbnRkL2NvcmUvdGltZSc7XG5pbXBvcnQgeyB2YWx1ZUZ1bmN0aW9uUHJvcCB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS91dGlsJztcbmltcG9ydCB7IERhdGVIZWxwZXJTZXJ2aWNlIH0gZnJvbSAnbmctem9ycm8tYW50ZC9pMThuJztcblxuaW1wb3J0IHsgQWJzdHJhY3RUYWJsZSB9IGZyb20gJy4vYWJzdHJhY3QtdGFibGUnO1xuaW1wb3J0IHsgRGF0ZUJvZHlSb3csIERhdGVDZWxsLCBZZWFyQ2VsbCB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IE5nQ2xhc3MsIE5nRm9yT2YsIE5nSWYsIE5nU3dpdGNoLCBOZ1N3aXRjaENhc2UsIE5nU3dpdGNoRGVmYXVsdCwgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbkBDb21wb25lbnQoe1xuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9jb21wb25lbnQtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICd5ZWFyLXRhYmxlJyxcbiAgZXhwb3J0QXM6ICd5ZWFyVGFibGUnLFxuICB0ZW1wbGF0ZVVybDogJ2Fic3RyYWN0LXRhYmxlLmh0bWwnLFxuICBpbXBvcnRzOiBbTmdJZiwgTmdGb3JPZiwgTmdDbGFzcywgTmdTd2l0Y2gsIE5nU3dpdGNoQ2FzZSwgTmdUZW1wbGF0ZU91dGxldCwgTmdTd2l0Y2hEZWZhdWx0XSxcbiAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBZZWFyVGFibGVDb21wb25lbnQgZXh0ZW5kcyBBYnN0cmFjdFRhYmxlIHtcbiAgb3ZlcnJpZGUgTUFYX1JPVyA9IDQ7XG4gIG92ZXJyaWRlIE1BWF9DT0wgPSAzO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0ZUhlbHBlcjogRGF0ZUhlbHBlclNlcnZpY2UpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgbWFrZUhlYWRSb3coKTogRGF0ZUNlbGxbXSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgbWFrZUJvZHlSb3dzKCk6IERhdGVCb2R5Um93W10ge1xuICAgIGNvbnN0IGN1cnJlbnRZZWFyID0gdGhpcy5hY3RpdmVEYXRlICYmIHRoaXMuYWN0aXZlRGF0ZS5nZXRZZWFyKCk7XG4gICAgY29uc3Qgc3RhcnRZZWFyID0gcGFyc2VJbnQoYCR7Y3VycmVudFllYXIgLyAxMH1gLCAxMCkgKiAxMDtcbiAgICBjb25zdCBlbmRZZWFyID0gc3RhcnRZZWFyICsgOTtcbiAgICBjb25zdCBwcmV2aW91c1llYXIgPSBzdGFydFllYXIgLSAxO1xuICAgIGNvbnN0IHllYXJzOiBEYXRlQm9keVJvd1tdID0gW107XG4gICAgbGV0IHllYXJWYWx1ZSA9IDA7XG5cbiAgICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgdGhpcy5NQVhfUk9XOyByb3dJbmRleCsrKSB7XG4gICAgICBjb25zdCByb3c6IERhdGVCb2R5Um93ID0ge1xuICAgICAgICBkYXRlQ2VsbHM6IFtdLFxuICAgICAgICB0cmFja0J5SW5kZXg6IHJvd0luZGV4XG4gICAgICB9O1xuICAgICAgZm9yIChsZXQgY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IHRoaXMuTUFYX0NPTDsgY29sSW5kZXgrKykge1xuICAgICAgICBjb25zdCB5ZWFyTnVtID0gcHJldmlvdXNZZWFyICsgeWVhclZhbHVlO1xuICAgICAgICBjb25zdCB5ZWFyID0gdGhpcy5hY3RpdmVEYXRlLnNldFllYXIoeWVhck51bSk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmRhdGVIZWxwZXIuZm9ybWF0KHllYXIubmF0aXZlRGF0ZSwgJ3l5eXknKTtcbiAgICAgICAgY29uc3QgaXNEaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZFllYXIoeWVhcik7XG4gICAgICAgIGNvbnN0IGNlbGw6IFllYXJDZWxsID0ge1xuICAgICAgICAgIHRyYWNrQnlJbmRleDogY29sSW5kZXgsXG4gICAgICAgICAgdmFsdWU6IHllYXIubmF0aXZlRGF0ZSxcbiAgICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICAgIGlzU2FtZURlY2FkZTogeWVhck51bSA+PSBzdGFydFllYXIgJiYgeWVhck51bSA8PSBlbmRZZWFyLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHllYXJOdW0gPT09ICh0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUuZ2V0WWVhcigpKSxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIHRpdGxlOiBjb250ZW50LFxuICAgICAgICAgIGNsYXNzTWFwOiB7fSxcbiAgICAgICAgICBpc0xhc3RDZWxsSW5QYW5lbDogeWVhci5nZXRZZWFyKCkgPT09IGVuZFllYXIsXG4gICAgICAgICAgaXNGaXJzdENlbGxJblBhbmVsOiB5ZWFyLmdldFllYXIoKSA9PT0gc3RhcnRZZWFyLFxuICAgICAgICAgIGNlbGxSZW5kZXI6IHZhbHVlRnVuY3Rpb25Qcm9wKHRoaXMuY2VsbFJlbmRlciEsIHllYXIpLCAvLyBDdXN0b21pemVkIGNvbnRlbnRcbiAgICAgICAgICBmdWxsQ2VsbFJlbmRlcjogdmFsdWVGdW5jdGlvblByb3AodGhpcy5mdWxsQ2VsbFJlbmRlciEsIHllYXIpLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHRoaXMuY2hvb3NlWWVhcihjZWxsLnZhbHVlLmdldEZ1bGxZZWFyKCkpLCAvLyBkb24ndCB1c2UgeWVhclZhbHVlIGhlcmUsXG4gICAgICAgICAgb25Nb3VzZUVudGVyOiAoKSA9PiB0aGlzLmNlbGxIb3Zlci5lbWl0KHllYXIpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRDZWxsUHJvcGVydHkoY2VsbCwgeWVhcik7XG4gICAgICAgIHJvdy5kYXRlQ2VsbHMucHVzaChjZWxsKTtcbiAgICAgICAgeWVhclZhbHVlKys7XG4gICAgICB9XG4gICAgICB5ZWFycy5wdXNoKHJvdyk7XG4gICAgfVxuICAgIHJldHVybiB5ZWFycztcbiAgfVxuXG4gIG92ZXJyaWRlIGdldENsYXNzTWFwKGNlbGw6IFllYXJDZWxsKTogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXRDbGFzc01hcChjZWxsKSxcbiAgICAgIFtgYW50LXBpY2tlci1jZWxsLWluLXZpZXdgXTogISFjZWxsLmlzU2FtZURlY2FkZVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGlzRGlzYWJsZWRZZWFyKHllYXI6IENhbmR5RGF0ZSk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZERhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdE9mTW9udGggPSB5ZWFyLnNldE1vbnRoKDApLnNldERhdGUoMSk7XG5cbiAgICBmb3IgKGxldCBkYXRlID0gZmlyc3RPZk1vbnRoOyBkYXRlLmdldFllYXIoKSA9PT0geWVhci5nZXRZZWFyKCk7IGRhdGUgPSBkYXRlLmFkZERheXMoMSkpIHtcbiAgICAgIGlmICghdGhpcy5kaXNhYmxlZERhdGUoZGF0ZS5uYXRpdmVEYXRlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIGFkZENlbGxQcm9wZXJ0eShjZWxsOiBEYXRlQ2VsbCwgeWVhcjogQ2FuZHlEYXRlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFzUmFuZ2VWYWx1ZSgpKSB7XG4gICAgICBjb25zdCBbc3RhcnRIb3ZlciwgZW5kSG92ZXJdID0gdGhpcy5ob3ZlclZhbHVlO1xuICAgICAgY29uc3QgW3N0YXJ0U2VsZWN0ZWQsIGVuZFNlbGVjdGVkXSA9IHRoaXMuc2VsZWN0ZWRWYWx1ZTtcbiAgICAgIC8vIFNlbGVjdGVkXG4gICAgICBpZiAoc3RhcnRTZWxlY3RlZD8uaXNTYW1lWWVhcih5ZWFyKSkge1xuICAgICAgICBjZWxsLmlzU2VsZWN0ZWRTdGFydCA9IHRydWU7XG4gICAgICAgIGNlbGwuaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRTZWxlY3RlZD8uaXNTYW1lWWVhcih5ZWFyKSkge1xuICAgICAgICBjZWxsLmlzU2VsZWN0ZWRFbmQgPSB0cnVlO1xuICAgICAgICBjZWxsLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRIb3ZlciAmJiBlbmRIb3Zlcikge1xuICAgICAgICBjZWxsLmlzSG92ZXJTdGFydCA9IHN0YXJ0SG92ZXIuaXNTYW1lWWVhcih5ZWFyKTtcbiAgICAgICAgY2VsbC5pc0hvdmVyRW5kID0gZW5kSG92ZXIuaXNTYW1lWWVhcih5ZWFyKTtcbiAgICAgICAgY2VsbC5pc0luSG92ZXJSYW5nZSA9IHN0YXJ0SG92ZXIuaXNCZWZvcmVZZWFyKHllYXIpICYmIHllYXIuaXNCZWZvcmVZZWFyKGVuZEhvdmVyKTtcbiAgICAgIH1cbiAgICAgIGNlbGwuaXNTdGFydFNpbmdsZSA9IHN0YXJ0U2VsZWN0ZWQgJiYgIWVuZFNlbGVjdGVkO1xuICAgICAgY2VsbC5pc0VuZFNpbmdsZSA9ICFzdGFydFNlbGVjdGVkICYmIGVuZFNlbGVjdGVkO1xuICAgICAgY2VsbC5pc0luU2VsZWN0ZWRSYW5nZSA9IHN0YXJ0U2VsZWN0ZWQ/LmlzQmVmb3JlWWVhcih5ZWFyKSAmJiB5ZWFyPy5pc0JlZm9yZVllYXIoZW5kU2VsZWN0ZWQpO1xuICAgICAgY2VsbC5pc1JhbmdlU3RhcnROZWFySG92ZXIgPSBzdGFydFNlbGVjdGVkICYmIGNlbGwuaXNJbkhvdmVyUmFuZ2U7XG4gICAgICBjZWxsLmlzUmFuZ2VFbmROZWFySG92ZXIgPSBlbmRTZWxlY3RlZCAmJiBjZWxsLmlzSW5Ib3ZlclJhbmdlO1xuICAgIH0gZWxzZSBpZiAoeWVhci5pc1NhbWVZZWFyKHRoaXMudmFsdWUpKSB7XG4gICAgICBjZWxsLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjZWxsLmNsYXNzTWFwID0gdGhpcy5nZXRDbGFzc01hcChjZWxsKTtcbiAgfVxuXG4gIHByaXZhdGUgY2hvb3NlWWVhcih5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5hY3RpdmVEYXRlLnNldFllYXIoeWVhcik7XG4gICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMudmFsdWUpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbn1cbiIsIjx0YWJsZSBjbGFzcz1cImFudC1waWNrZXItY29udGVudFwiIGNlbGxzcGFjaW5nPVwiMFwiIHJvbGU9XCJncmlkXCI+XG4gIEBpZihoZWFkUm93ICYmIGhlYWRSb3cubGVuZ3RoID4gMCkge1xuICAgIDx0aGVhZD5cbiAgICAgIDx0ciByb2xlPVwicm93XCI+XG4gICAgICAgIEBpZihzaG93V2Vlaykge1xuICAgICAgICAgIDx0aCByb2xlPVwiY29sdW1uaGVhZGVyXCI+PC90aD5cbiAgICAgICAgfVxuICAgICAgICBAZm9yKGNlbGwgb2YgaGVhZFJvdzsgdHJhY2sgY2VsbCkge1xuICAgICAgICAgIDx0aCByb2xlPVwiY29sdW1uaGVhZGVyXCIgdGl0bGU9XCJ7eyBjZWxsLnRpdGxlIH19XCI+IHt7IGNlbGwuY29udGVudCB9fSA8L3RoPlxuICAgICAgICB9XG4gICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gIH1cblxuICA8dGJvZHk+XG4gICAgQGZvcihyb3cgb2YgYm9keVJvd3M7IHRyYWNrIHJvdy50cmFja0J5SW5kZXgpIHtcbiAgICAgIDx0ciBbbmdDbGFzc109XCJyb3cuY2xhc3NNYXAhXCIgcm9sZT1cInJvd1wiPlxuICAgICAgICBAaWYocm93LndlZWtOdW0pIHtcbiAgICAgICAgICA8dGQgcm9sZT1cImdyaWRjZWxsXCIgY2xhc3M9XCJ7eyBwcmVmaXhDbHMgfX0tY2VsbC13ZWVrXCI+IHt7IHJvdy53ZWVrTnVtIH19IDwvdGQ+XG4gICAgICAgIH1cbiAgICAgICAgQGZvcihjZWxsIG9mIHJvdy5kYXRlQ2VsbHM7IHRyYWNrIGNlbGwudHJhY2tCeUluZGV4KSB7XG4gICAgICAgICAgPHRkXG4gICAgICAgICAgICB0aXRsZT1cInt7IGNlbGwudGl0bGUgfX1cIlxuICAgICAgICAgICAgcm9sZT1cImdyaWRjZWxsXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cImNlbGwuY2xhc3NNYXAhXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjZWxsLmlzRGlzYWJsZWQgPyBudWxsIDogY2VsbC5vbkNsaWNrKClcIlxuICAgICAgICAgICAgKG1vdXNlZW50ZXIpPVwiY2VsbC5vbk1vdXNlRW50ZXIoKVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgQHN3aXRjaCAocHJlZml4Q2xzKSB7XG4gICAgICAgICAgICAgIEBjYXNlKCdhbnQtcGlja2VyJykge1xuICAgICAgICAgICAgICAgIEBpZihjZWxsLmlzVGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCIkYW55KGNlbGwuY2VsbFJlbmRlcik7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBjZWxsLnZhbHVlIH1cIiAvPlxuICAgICAgICAgICAgICAgIH1AZWxzZSBpZihjZWxsLmlzTm9uRW1wdHlTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgIDxzcGFuIFtpbm5lckhUTUxdPVwiY2VsbC5jZWxsUmVuZGVyXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIH1AZWxzZSB7XG4gICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwie3sgcHJlZml4Q2xzIH19LWNlbGwtaW5uZXJcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cImNlbGwuaXNTZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiY2VsbC5pc0Rpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAge3sgY2VsbC5jb250ZW50IH19XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgQGNhc2UoJ2FudC1waWNrZXItY2FsZW5kYXInKSB7XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ7eyBwcmVmaXhDbHMgfX0tZGF0ZSBhbnQtcGlja2VyLWNlbGwtaW5uZXJcIlxuICAgICAgICAgICAgICAgICAgW2NsYXNzLmFudC1waWNrZXItY2FsZW5kYXItZGF0ZS10b2RheV09XCJjZWxsLmlzVG9kYXlcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIEBpZihjZWxsLmZ1bGxDZWxsUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCIkYW55KGNlbGwuZnVsbENlbGxSZW5kZXIpOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogY2VsbC52YWx1ZSB9XCIgLz5cbiAgICAgICAgICAgICAgICAgIH1AZWxzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInt7IHByZWZpeENscyB9fS1kYXRlLXZhbHVlXCI+e3sgY2VsbC5jb250ZW50IH19PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ7eyBwcmVmaXhDbHMgfX0tZGF0ZS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIiRhbnkoY2VsbC5jZWxsUmVuZGVyKTsgY29udGV4dDogeyAkaW1wbGljaXQ6IGNlbGwudmFsdWUgfVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgIH1cblxuICAgICAgPC90cj5cbiAgICB9XG4gIDwvdGJvZHk+XG48L3RhYmxlPlxuIl19